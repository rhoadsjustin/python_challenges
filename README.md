![General Assembly Logo](http://i.imgur.com/ke8USTq.png)

# Learning Python

You've learned Ruby, C, C++, JavaScript and SQL. Getting started with a totally new language doesn't have to be hard. The biggest key is to practice doing something that you *already know* in the context of the new language. This is called a *transfer task*. The more languages and computer science concepts you learn, the easier new ones become to pick up and its mostly syntax, quirks and language-specific tools that become the tricky part.

Now, your task is to *teach yourself* a bit of Python. The goal here isn't to become a Python master, but to explore and learn a bit about a new language.

**All exercises below should be done with Python 3**

## Goals:

By the end of this exercise, you should be able to:

- Create a simple python program
- Execute a simple python program
- Articulate basic differences between Python and other languages you know
- Feel comfortable understanding what is generally happening in most basic python programs

## Installing Python

Your Mac comes with Python 2.7. We want Python 3.

`brew install python3`

Execute the Python REPL with:

`python3`

Execute a Python program with:

`python3 program.py`

## Research: What is Python

Your first task is to research Python to be able to understand some of its basic concepts. Edit this `README.md` file to answer the below questions:

##### What paradigms does Python support?

Object-oriented, procedural, and functional.


##### What typing discipline does it follow?
dynamically typed language.

##### Is it a high or low level language?
It is a high level language.

##### Does it have built in memory management and garbage collection?
Yes it has built in memore management and yes it has garbage collection.

##### What languages was Python influenced by?
	ABC, ALGOL 68, C, Haskell, Icon, Lisp, Modula-3, Perl, Java

##### Is it a compiled or interpeted language?
It's worth noting that languages are not interpreted or compiled, but rather language implementations either interpret or compile code. You noted that Ruby is an "interpreted language", but you can compile Ruby à la MacRuby, so it's not always an interpreted language.

Pretty much every Python implementation consists of an interpreter (rather than a compiler). The .pyc files you see are byte code for the Python virtual machine (similar to Java's .class files). They are not the same as the machine code generated by a C compiler for a native machine architecture. Some Python implementations, however, do consist of a just-in-time compiler that will compile Python byte code into native machine code.

##### Does it have strong support for functional programming?
Yes

##### What's the deal with Python 2 vs Python 3?
Print: In Python 2, “print” is treated as a statement rather than a function. There is no need to wrap the text you want to print in parentheses, although you can if you want. This can be confusing, as most other actions in Python use functions that require the arguments to be placed inside parentheses. It can also lead to unexpected outcomes if you put parentheses around a comma-separated list of items that you want to print. In contrast, Python 3 explicitly treats “print” as a function, which means you have to pass the items you need to print to the function in parentheses in the standard way, or you will get a syntax error. Some Python 2 programmers find this change annoying, but it can help to prevent mistakes.
Integer Division: Python 2 treats numbers that you type without any digits after the decimal point as integers, which can lead to some unexpected results during division. For example, if you type the expression 3 / 2 in Python 2 code, the result of the evaluation will be 1, not 1.5 as you might expect. This is because Python 2 assumes that you want the result of your division to be an integer, so it rounds the calculation down to the nearest whole number. In order to get the result 1.5, you would have to write 3.0 / 2.0 to tell Python that you want it to return a float, that is, to include digits after the decimal point in the result. Python 3 evaluates 3 / 2 as 1.5 by default, which is more intuitive for new programmers.
List Comprehension Loop Variables: In previous versions of Python, giving the variable that is iterated over in a list comprehension the same name as a global variable could lead to the value of the global variable being changed — something you usually don’t want. This irritating bug has been fixed in Python 3, so you can use a variable name you already used for the control variable in your list comprehension without worrying about it leaking out and messing with the values of the variables in the rest of your code.
Unicode Strings: Python 3 stores strings as Unicode by default, whereas Python 2 requires you to mark a string with a “u” if you want to store it as Unicode. Unicode strings are more versatile than ASCII strings, which are the Python 2 default, as they can store letters from foreign languages as well as emoji and the standard Roman letters and numerals. You can still label your Unicode strings with a “u” if you want to make sure your Python 3 code is compatible with Python 2.
Raising Exceptions: Python 3 requires different syntax for raising exceptions. If you want to output an error message to the user, you need to use the syntax:


##### How do you open a REPL for Python?
you type "python" into the terminal 

##### How does one execute a Python program?
"python yourfilename.py" in the terminal

## Read: The Zen of Python

> The Zen of Python, by Tim Peters
>
> Beautiful is better than ugly.
> Explicit is better than implicit.
> Simple is better than complex.
> Complex is better than complicated.
> Flat is better than nested.
> Sparse is better than dense.
> Readability counts.
> Special cases aren't special enough to break the rules.
> Although practicality beats purity.
> Errors should never pass silently.
> Unless explicitly silenced.
> In the face of ambiguity, refuse the temptation to guess.
> There should be one-- and preferably only one --obvious way to do it.
> Although that way may not be obvious at first unless you're Dutch.
> Now is better than never.
> Although never is often better than *right* now.
> If the implementation is hard to explain, it's a bad idea.
> If the implementation is easy to explain, it may be a good idea.
> Namespaces are one honking great idea -- let's do more of those!

## Hello World

Write a program in `hello_world/hello_world.py` that prints 'Hello, World!' to the standard output (terminal).

## Fizzbuzz

Write a program in `fizzbuzz/fizzbuzz.py` that does the following:

For numbers 1 through 100, print `fizz` if the number is divisible by 3, `buzz` if the number is divisible by 5 and `fizzbuzz` if the number if the number is divisible by both 3 and 5. If the number isn't divisible by 3 or 5, just output the number itself.

The output should look something like `1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 Fizz Buzz 16 17 Fizz...`

## Fibonacci

Write a program in `fibonacci/fib.py` that will output the N-th term of the [Fibonacci sequence](http://en.wikipedia.org/wiki/Fibonacci_number).

For example: `print fib(6)` should output `8`.

## Project Euler Problem 1

Project Euler's first problem is:

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
> Find the sum of all the multiples of 3 or 5 below 1000.

Write the code to complete this in `euler_1/sum_of_natural_numbers.py`

## Conclusion

How does Python compare to other langauges you've used? Which language is is closest to?
